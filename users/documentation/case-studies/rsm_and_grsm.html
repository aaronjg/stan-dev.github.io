<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />


<meta name="author" content="Daniel C. Furr" />

<meta name="date" content="2017-06-28" />

<title>Rating scale and generalized rating scale models with latent regression</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<link rel="stylesheet"
      href="site_libs/highlight/default.css"
      type="text/css" />
<script src="site_libs/highlight/highlight.js"></script>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs && document.readyState && document.readyState === "complete") {
   window.setTimeout(function() {
      hljs.initHighlighting();
   }, 0);
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>

<link rel="stylesheet" href="rsm_and_grsm_files/styles.css" type="text/css" />

</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
button.code-folding-btn:focus {
  outline: none;
}
</style>


<div class="container-fluid main-container">

<!-- tabsets -->
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});
</script>

<!-- code folding -->






<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Rating scale and generalized rating scale models with latent regression</h1>
<h4 class="author"><em>Daniel C. Furr</em></h4>
<h4 class="date"><em>June 28, 2017</em></h4>

</div>

<div id="TOC">
<ul>
<li><a href="#rating-scale-model-with-latent-regression"><span class="toc-section-number">1</span> Rating scale model with latent regression</a><ul>
<li><a href="#overview-of-the-model"><span class="toc-section-number">1.1</span> Overview of the model</a></li>
<li><a href="#stan-code-for-a-simple-rating-scale-model"><span class="toc-section-number">1.2</span> <strong>Stan</strong> code for a simple rating scale model</a></li>
<li><a href="#stan-code-for-the-rating-scale-model-with-latent-regression"><span class="toc-section-number">1.3</span> <strong>Stan</strong> code for the rating scale model with latent regression</a></li>
<li><a href="#simulation-for-parameter-recovery"><span class="toc-section-number">1.4</span> Simulation for parameter recovery</a></li>
</ul></li>
<li><a href="#generalized-rating-scale-model-with-latent-regression"><span class="toc-section-number">2</span> Generalized rating scale model with latent regression</a><ul>
<li><a href="#overview-of-the-model-1"><span class="toc-section-number">2.1</span> Overview of the model</a></li>
<li><a href="#stan-code-for-the-generalized-rating-scale-model-with-latent-regression"><span class="toc-section-number">2.2</span> <strong>Stan</strong> code for the generalized rating scale model with latent regression</a></li>
<li><a href="#simulation-for-parameter-recovery-1"><span class="toc-section-number">2.3</span> Simulation for parameter recovery</a></li>
</ul></li>
<li><a href="#example-application"><span class="toc-section-number">3</span> Example application</a><ul>
<li><a href="#data"><span class="toc-section-number">3.1</span> Data</a></li>
<li><a href="#rating-scale-model-results"><span class="toc-section-number">3.2</span> Rating scale model results</a></li>
<li><a href="#generalized-rating-scale-model-results"><span class="toc-section-number">3.3</span> Generalized rating scale model results</a></li>
</ul></li>
<li><a href="#references"><span class="toc-section-number">4</span> References</a></li>
</ul>
</div>

<p>This case study uses <strong>Stan</strong> to fit the Rating Scale Model (RSM) and Generalized Rating Scale Model (GRSM), including a latent regression for person ability for both. Analysis is performed with <strong>R</strong>, making use of the <strong>rstan</strong> and <strong>edstan</strong> packages. <strong>rstan</strong> is the implementation of <strong>Stan</strong> for <strong>R</strong>, and <strong>edstan</strong> provides <strong>Stan</strong> models for item response theory and several convenience functions.</p>
<p>The <strong>edstan</strong> package is available on <strong>CRAN</strong>, but a more up to date version may often be found on Github. The following <strong>R</strong> code may be used to install the package from Github.</p>
<pre class="r"><code># Install edstan from Github rather than CRAN
install.packages(&quot;devtools&quot;)
devtools::install_github(&quot;danielcfurr/edstan&quot;)</code></pre>
<p>The following <strong>R</strong> code loads the necessary packages and then sets some <strong>rstan</strong> options, which causes the compiled <strong>Stan</strong> model to be saved for future use and the MCMC chains to be executed in parallel.</p>
<pre class="r"><code># Load R packages
library(rstan)
library(ggplot2)
library(edstan)
library(ltm)
rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())</code></pre>
<p>The case study uses <strong>R</strong> version 3.3.3, <strong>rstan</strong> version 2.15.1, <strong>ggplot2</strong> version 2.2.1, and <strong>edstan</strong> version 1.0.7. Also, the example data are from <strong>TAM</strong> version 1.0.0. Readers may wish to check the versions for their installed packages using the <code>packageVersion()</code> function.</p>
<div id="rating-scale-model-with-latent-regression" class="section level1">
<h1><span class="header-section-number">1</span> Rating scale model with latent regression</h1>
<div id="overview-of-the-model" class="section level2">
<h2><span class="header-section-number">1.1</span> Overview of the model</h2>
<p>The rating scale model <span class="citation">(Andrich 1978)</span> is appropriate for item response data that involves Likert scale responses. The version presented includes a latent regression. However, the latent regression part of the model may be restricted to an intercept only, resulting in the standard rating scale model.</p>
<p><span class="math display">\[
\Pr(Y_{ij} = y,~y &gt; 0 | \theta_j, \beta_i, \kappa_s) =
\frac{\exp \sum_{s=1}^y (\theta_j - \beta_i - \kappa_s)}
     {1 + \sum_{k=1}^{m} \exp \sum_{s=1}^k (\theta_j - \beta_i - \kappa_s)}
\]</span> <span class="math display">\[
\Pr(Y_{ij} = y,~y = 0 | \theta_j, \beta_i, \kappa_s) =
\frac{1}
     {1 + \sum_{k=1}^{m} \exp \sum_{s=1}^k (\theta_j - \beta_i - \kappa_s)}
\]</span> <span class="math display">\[
\theta_j \sim \mathrm{N}(w_{j}&#39; \lambda, \sigma^2)
\]</span></p>
<p>Variables:</p>
<ul>
<li><span class="math inline">\(i = 1 \ldots I\)</span> indexes items.</li>
<li><span class="math inline">\(j = 1 \ldots J\)</span> indexes persons.</li>
<li><span class="math inline">\(Y_{ij} \in \{ 0 \ldots m \}\)</span> is the response of person <span class="math inline">\(j\)</span> to item <span class="math inline">\(i\)</span></li>
<li><span class="math inline">\(m\)</span> is simultaneously the maximum score and number of step difficulty parameters per item.</li>
<li><span class="math inline">\(w_{j}\)</span> is the vector of covariates for person <span class="math inline">\(j\)</span>, the first element of which <em>must</em> equal one for a model intercept. <span class="math inline">\(w_{j}\)</span> may be assembled into a <span class="math inline">\(J\)</span>-by-<span class="math inline">\(K\)</span> covariate matrix <span class="math inline">\(W\)</span>, where <span class="math inline">\(K\)</span> is number of elements in <span class="math inline">\(w_j\)</span>.</li>
</ul>
<p>Parameters:</p>
<ul>
<li><span class="math inline">\(\beta_i\)</span> is the item-specific difficulty for item <span class="math inline">\(i\)</span>.</li>
<li><span class="math inline">\(\kappa_s\)</span> is the <span class="math inline">\(s\)</span>-th step difficulty, constant across items.</li>
<li><span class="math inline">\(\theta_j\)</span> is the ability for person <span class="math inline">\(j\)</span>.</li>
<li><span class="math inline">\(\lambda\)</span> is a vector of latent regression parameters of length <span class="math inline">\(K\)</span>.</li>
<li><span class="math inline">\(\sigma^2\)</span> is the variance for the ability distribution.</li>
</ul>
<p>Constraints:</p>
<ul>
<li>The last item difficulty parameter, <span class="math inline">\(\beta_I\)</span>, is constrained to be the negative sum of the other difficulties, resulting in the average item difficulty parameter being zero.</li>
<li>The last step difficulty parameter, <span class="math inline">\(\kappa_m\)</span>, is likewise constrained to be the negative sum of the other step difficulties, resulting in the average step difficulty being zero.</li>
</ul>
<p>Priors:</p>
<ul>
<li><span class="math inline">\(\sigma \sim \mathrm{Exp}(.1)\)</span> is weakly informative for the person standard deviation.</li>
<li><span class="math inline">\(\beta_i \sim \mathrm{N}(0, 9)\)</span> is also weakly informative.</li>
<li><span class="math inline">\(\kappa_s \sim \mathrm{N}(0, 9)\)</span> is weakly informative.</li>
<li><span class="math inline">\(\lambda \sim t_3(0, 1)\)</span>, where <span class="math inline">\(t_3\)</span> is the Student’s <span class="math inline">\(t\)</span> distribution with three degrees of freedom, <em>and</em> the covariates have been transformed as follows: (1) continuous covariates are mean-centered and then divided by two times their standard deviations, (2) binary covariates are mean-centered and divided their maximum minus minimum values, and (3) no change is made to the constant, set to one, for the model intercept. This approach to setting priors is similar to one that has been suggested for logistic regression <span class="citation">(Gelman et al. 2008)</span>. It is possible to adjust the coefficients back to the scales of the original covariates.</li>
</ul>
</div>
<div id="stan-code-for-a-simple-rating-scale-model" class="section level2">
<h2><span class="header-section-number">1.2</span> <strong>Stan</strong> code for a simple rating scale model</h2>
<p>A simple <strong>Stan</strong> model is described before discussing the complete model, as the code for the complete model is somewhat cumbersome. The simpler model, printed below, omits the latent regression and so does not require rescaling of the person covariates or <code>lambda</code>. The mean of the person distribution is set to zero and the constraint is removed from the item difficulties, which also differs from the complete model.</p>
<pre class="r"><code># Print the simple RSM from the edstan package
simple_rsm_file &lt;- system.file(&quot;extdata/rsm_simple.stan&quot;, 
                               package = &quot;edstan&quot;)
cat(readLines(simple_rsm_file), sep = &quot;\n&quot;)</code></pre>
<pre><code>functions {
  real rsm(int y, real theta, real beta, vector kappa) {
    vector[rows(kappa) + 1] unsummed;
    vector[rows(kappa) + 1] probs;
    unsummed = append_row(rep_vector(0, 1), theta - beta - kappa);
    probs = softmax(cumulative_sum(unsummed));
    return categorical_lpmf(y + 1 | probs);
  }
}
data {
  int&lt;lower=1&gt; I;                // # items
  int&lt;lower=1&gt; J;                // # persons
  int&lt;lower=1&gt; N;                // # responses
  int&lt;lower=1,upper=I&gt; ii[N];    // i for n
  int&lt;lower=1,upper=J&gt; jj[N];    // j for n
  int&lt;lower=0&gt; y[N];             // response for n; y in {0 ... m_i}
}
transformed data {
  int m;                         // # steps
  m = max(y);
}
parameters {
  vector[I] beta;
  vector[m-1] kappa_free;
  vector[J] theta;
  real&lt;lower=0&gt; sigma;
}
transformed parameters {
  vector[m] kappa;
  kappa[1:(m-1)] = kappa_free;
  kappa[m] = -1*sum(kappa_free);
}
model {
  beta ~ normal(0, 3);
  target += normal_lpdf(kappa | 0, 3);
  theta ~ normal(0, sigma);
  sigma ~ exponential(.1);
  for (n in 1:N)
    target += rsm(y[n], theta[jj[n]], beta[ii[n]], kappa);
}</code></pre>
<p>The functions block includes a user-specified function <code>rsm()</code>, which accepts a response <code>y</code>, a value for <code>theta</code>, a scalar <code>beta</code> for one item, and the vector <code>kappa</code>. With these inputs, it returns the model-predicted log probability for the response. Later, in the model block, <code>rsm()</code> is used to get the likelihood of the observed item responses.</p>
<p>Looking to the data block, data are fed into the model in vector form. That is, <code>y</code> is a long vector of scored item responses, and <code>ii</code> and <code>jj</code> indicate with which item and person each element in <code>y</code> is associated. These three vectors are of length <code>N</code>, which is either equal to <code>I</code> times <code>J</code> or less if there are missing responses. Then in the transformed data block, the variable <code>m</code> is created, which represents the number of steps per item.</p>
<p>In the parameters block, <code>kappa_free</code> is declared as a vector of length <code>m - 1</code> and represents the unconstrained step parameters. In the transformed parameters block, the constrained step parameter is appened to <code>kappa_free</code> to make <code>kappa</code>, which is the complete vector of step difficulties. The other parameters are handled in conventional ways, with <code>sigma</code> being assigned a lower bound of zero because it is a standard deviation.</p>
<p>The model block indicates the priors and the likelihood. The <code>target += ...</code> syntax for the prior on <code>kappa</code> is a manual way of incrementing the log posterior used when the prior is placed on a transformed parameter. The likelihood uses similar syntax along with the <code>rsm()</code> function.</p>
</div>
<div id="stan-code-for-the-rating-scale-model-with-latent-regression" class="section level2">
<h2><span class="header-section-number">1.3</span> <strong>Stan</strong> code for the rating scale model with latent regression</h2>
<p>The RSM with latent regression will be discussed in relation to the simpler model, and both models are equivalent when the latent regression is restricted to an intercept only. The model with latent regression, which is featured in <strong>edstan</strong>, is printed below. It is more complicated than is typically necessary for a <strong>Stan</strong> model because it is written to apply sensible priors automatically for parameters associated with arbitrarily scaled covariates.</p>
<pre><code>functions {
  real rsm(int y, real theta, real beta, vector kappa) {
    vector[rows(kappa) + 1] unsummed;
    vector[rows(kappa) + 1] probs;
    unsummed = append_row(rep_vector(0, 1), theta - beta - kappa);
    probs = softmax(cumulative_sum(unsummed));
    return categorical_lpmf(y + 1 | probs);
  }
  matrix obtain_adjustments(matrix W) {
    real min_w;
    real max_w;
    int minmax_count;
    matrix[2, cols(W)] adj;
    adj[1, 1] = 0;
    adj[2, 1] = 1;
    if(cols(W) &gt; 1) {
      for(k in 2:cols(W)) {                       // remaining columns
        min_w = min(W[1:rows(W), k]);
        max_w = max(W[1:rows(W), k]);
        minmax_count = 0;
        for(j in 1:rows(W))
          minmax_count = minmax_count + W[j,k] == min_w || W[j,k] == max_w;
        if(minmax_count == rows(W)) {       // if column takes only 2 values
          adj[1, k] = mean(W[1:rows(W), k]);
          adj[2, k] = (max_w - min_w);
        } else {                            // if column takes &gt; 2 values
          adj[1, k] = mean(W[1:rows(W), k]);
          adj[2, k] = sd(W[1:rows(W), k]) * 2;
        }
      }
    }
    return adj;
  }
}
data {
  int&lt;lower=1&gt; I;                // # items
  int&lt;lower=1&gt; J;                // # persons
  int&lt;lower=1&gt; N;                // # responses
  int&lt;lower=1,upper=I&gt; ii[N];    // i for n
  int&lt;lower=1,upper=J&gt; jj[N];    // j for n
  int&lt;lower=0&gt; y[N];             // response for n; y in {0 ... m_i}
  int&lt;lower=1&gt; K;                // # person covariates
  matrix[J,K] W;                 // person covariate matrix
}
transformed data {
  int m;                         // # steps
  matrix[2,K] adj;               // values for centering and scaling covariates
  matrix[J,K] W_adj;             // centered and scaled covariates
  m = max(y);
  adj = obtain_adjustments(W);
  for(k in 1:K) for(j in 1:J)
      W_adj[j,k] = (W[j,k] - adj[1,k]) / adj[2,k];
}
parameters {
  vector[I-1] beta_free;
  vector[m-1] kappa_free;
  vector[J] theta;
  real&lt;lower=0&gt; sigma;
  vector[K] lambda_adj;
}
transformed parameters {
  vector[I] beta;
  vector[m] kappa;
  beta[1:(I-1)] = beta_free;
  beta[I] = -1*sum(beta_free);
  kappa[1:(m-1)] = kappa_free;
  kappa[m] = -1*sum(kappa_free);
}
model {
  target += normal_lpdf(beta | 0, 3);
  target += normal_lpdf(kappa | 0, 3);
  theta ~ normal(W_adj*lambda_adj, sigma);
  lambda_adj ~ student_t(3, 0, 1);
  sigma ~ exponential(.1);
  for (n in 1:N)
    target += rsm(y[n], theta[jj[n]], beta[ii[n]], kappa);
}
generated quantities {
  vector[K] lambda;
  lambda[2:K] = lambda_adj[2:K] ./ to_vector(adj[2,2:K]);
  lambda[1] = W_adj[1, 1:K]*lambda_adj[1:K] - W[1, 2:K]*lambda[2:K];
}</code></pre>
<p>The complete model adds <code>obtain_adjustments()</code> to the functions block, which is used to adjust the covariate matrix. In brief, the model operates on the adjusted covariate matrix, <code>W_adj</code>, and then in the generated quantities block determines what the latent regression coefficients would be on the original scale of the covariates. For a more in depth discussion of <code>obtain_adjustments()</code> and the transformations related to the latent regression, see the <a href="http://mc-stan.org/documentation/case-studies/rasch_and_2pl.html">Rasch and 2PL case study</a>.</p>
<p>In the data block, the number of covariates (plus the intercept) <code>K</code> is now required, as is the matrix of covariates <code>W</code>. The parameters <code>beta_free</code>, <code>kappa_free</code>, <code>theta</code>, <code>sigma</code>, and <code>lambda</code> are declared in the parameters block. The unconstrained item parameters are contained in <code>beta_free</code>. In the transformed parameters block, <code>beta</code> is created by appending the constrained item difficulty to <code>beta_free</code>. The model block contains the priors and the likelihood.</p>
</div>
<div id="simulation-for-parameter-recovery" class="section level2">
<h2><span class="header-section-number">1.4</span> Simulation for parameter recovery</h2>
<p>The <strong>Stan</strong> model is fit to a simulated dataset to evaluate it’s ability to recover the generating parameter values. The <strong>R</strong> code that follows simulates a dataset conforming to the model.</p>
<pre class="r"><code># Set parameters for the simulated data
J &lt;- 500
sigma &lt;- 1.2
lambda &lt;- c(-10*.05, .05, .5, -.025)
w_2 &lt;- rnorm(J, 10, 5)
w_3 &lt;- rbinom(J, 1, .5)
W &lt;- cbind(1, w_2, w_3, w_2*w_3)

# Set item parameters
I &lt;- 20  # Number of items
S &lt;- 5   # Number of response catetories
beta &lt;- seq(from = -1, to = 1, length.out = I)
kappa &lt;- seq(from = -1, to = 1, length.out = S - 1)

# A function to simulate responses from the model
simulate_response &lt;- function(theta, beta, kappa) {
  unsummed &lt;- c(0, theta - beta - kappa)
  numerators &lt;- exp(cumsum(unsummed))
  denominator &lt;- sum(numerators)
  response_probs &lt;- numerators/denominator
  simulated_y &lt;- sample(1:length(response_probs) - 1, size = 1,
                        prob = response_probs)
  return(simulated_y)
}

# Calculate or sample remaining variables and parameters
N &lt;- I*J
ii &lt;- rep(1:I, times = J)
jj &lt;- rep(1:J, each = I)
rsm_theta &lt;-  rnorm(J, W %*% matrix(lambda), sigma)
rsm_y &lt;- numeric(N)
for(n in 1:N) {
  rsm_y[n] &lt;- simulate_response(rsm_theta[jj[n]], beta[ii[n]], kappa)
}

# Assemble the data list using an edstan function
sim_rsm_list &lt;- irt_data(y = rsm_y, ii = ii, jj = jj, 
                         covariates = as.data.frame(W), 
                         formula = NULL)</code></pre>
<p>The simulated data consists of 20 items having 3 response categories and 500 persons. The person covariate vectors <span class="math inline">\(w_j\)</span> include (1) a value of one for the model intercept, (2) a random draw from a normal distribution with mean of 10 and standard deviation of 5, (3) an indicator variable taking values of zero and one, and (4) an interaction between the two. These are chosen to represent a difficult case for assigning automatic priors for the latent regression coefficients. The generating coefficients <span class="math inline">\(\lambda\)</span> for the latent regression are -0.5, 0.05, 0.5, and -0.025. The abilities <span class="math inline">\(\theta\)</span> are random draws from a normal distribution with a mean generated from the latent regression and a standard deviation <span class="math inline">\(\sigma = 1.2\)</span>.</p>
<pre class="r"><code># Plot mean ability conditional on the covariates
f1 &lt;- function(x) lambda[1] + x*lambda[2]
f2 &lt;- function(x) lambda[1] + lambda[3] + x*(lambda[2] + lambda[4])
ggplot(data.frame(w2 = c(0, 20))) +
  aes(x = w2) +
  stat_function(fun = f1, color = &quot;red&quot;) +
  stat_function(fun = f2, color = &quot;blue&quot;) +
  ylab(&quot;Mean generated ability&quot;) +
  xlab(&quot;Value for continous covariate&quot;)</code></pre>
<div class="figure">
<img src="rsm_and_grsm_files/figure-html/rsm_sim_theta_plot-1.png" alt="Mean of generated abilities as a function of the continuous covariate. A line is shown separately for the two groups identified by the binary variable." width="672" />
<p class="caption">
Mean of generated abilities as a function of the continuous covariate. A line is shown separately for the two groups identified by the binary variable.
</p>
</div>
<p>The simulated dataset is next fit with <strong>Stan</strong> using <code>irt_stan()</code> from the <strong>edstan</strong> package. <code>irt_stan()</code> is merely a wrapper for <code>stan()</code> in <strong>rstan</strong>. Using 1,000 posterior draws per chain may be somewhat excessive as we are mainly interested in the posterior means of the parameters. However, as parameter recovery will be evaluated using the 2.5th and 97.5th percentiles of the posterior, the large number of posterior samples is warranted.</p>
<pre class="r"><code>#Fit model to simulated data
sim_rsm_fit &lt;- irt_stan(sim_rsm_list, model = &quot;rsm_latent_reg.stan&quot;, 
                        chains = 4, iter = 1000)</code></pre>
<p>The highest value for <span class="math inline">\(\hat R\)</span> was 1.005 for all parameters and the log posterior, suggesting that the chains have converged. The <strong>Stan</strong> model is evaluated in terms of its ability to recover the generating values of the parameters. The R code below prepares a plot in which the points indicate the difference between the posterior means and generating values for the parameters of main interest. This difference is referred to as discrepancy. The lines indicate the 95% poster intervals for the difference, defined as the 2.5th and 97.5th percentiles of the posterior draws. Ideally, (nearly) all the 95% intervals would include zero.</p>
<pre class="r"><code># Get estimated and generating values for wanted parameters
rsm_generating_values &lt;- c(beta, kappa, lambda, sigma)
rsm_estimated_values &lt;- summary(sim_rsm_fit,  
                                pars = c(&quot;beta&quot;, &quot;kappa&quot;, &quot;lambda&quot;, &quot;sigma&quot;),
                                probs = c(.025, .975))
rsm_estimated_values &lt;- rsm_estimated_values[[&quot;summary&quot;]]

# Make a data frame of the discrepancies
rsm_discrep &lt;- data.frame(par = rownames(rsm_estimated_values),
                          mean = rsm_estimated_values[, &quot;mean&quot;],
                          p025 = rsm_estimated_values[, &quot;2.5%&quot;],
                          p975 = rsm_estimated_values[, &quot;97.5%&quot;],
                          gen = rsm_generating_values)
rsm_discrep$par &lt;- with(rsm_discrep, factor(par, rev(par)))
rsm_discrep$lower &lt;- with(rsm_discrep, p025 - gen)
rsm_discrep$middle &lt;- with(rsm_discrep, mean - gen)
rsm_discrep$upper &lt;- with(rsm_discrep, p975 - gen)

# Plot the discrepancies
ggplot(rsm_discrep) +
  aes(x = par, y = middle, ymin = lower, ymax = upper) +
  scale_x_discrete() +
  labs(y = &quot;Discrepancy&quot;, x = NULL) +
  geom_abline(intercept = 0, slope = 0, color = &quot;white&quot;) +
  geom_linerange() +
  geom_point(size = 2) +
  theme(panel.grid = element_blank()) +
  coord_flip()</code></pre>
<div class="figure">
<img src="rsm_and_grsm_files/figure-html/sim_rsm_dif-1.png" alt="Discrepancies between estimated and generating parameters. Points indicate the difference between the posterior means and generating values for a parameter, and horizontal lines indicate 95% posterior intervals for the difference. Most of the discrepancies are about zero, indicating that **Stan** successfully recovers the true parameters." width="672" />
<p class="caption">
Discrepancies between estimated and generating parameters. Points indicate the difference between the posterior means and generating values for a parameter, and horizontal lines indicate 95% posterior intervals for the difference. Most of the discrepancies are about zero, indicating that <strong>Stan</strong> successfully recovers the true parameters.
</p>
</div>
</div>
</div>
<div id="generalized-rating-scale-model-with-latent-regression" class="section level1">
<h1><span class="header-section-number">2</span> Generalized rating scale model with latent regression</h1>
<div id="overview-of-the-model-1" class="section level2">
<h2><span class="header-section-number">2.1</span> Overview of the model</h2>
<p>The GRSM extends the RSM by including a discrimination term. The version presented includes a latent regression. However, the latent regression may be restricted to a model intercept, resulting in the standard generalized rating scale model.</p>
<p><span class="math display">\[
\Pr(Y_{ij} = y,~y &gt; 0 | \theta_j, \alpha_i, \beta_i, \kappa_s) =
\frac{\exp \sum_{s=1}^y (\alpha_i \theta_j - \beta_i - \kappa_s)}
     {1 + \sum_{k=1}^{m} \exp \sum_{s=1}^k (\alpha_i \theta_j - \beta_i - \kappa_s)}
\]</span> <span class="math display">\[
\Pr(Y_{ij} = y,~y = 0 | \theta_j, \alpha_i, \alpha_i, \beta_i) =
\frac{1}
     {1 + \sum_{k=1}^{m} \exp \sum_{s=1}^k (\alpha_i \theta_j - \beta_i - \kappa_s)}
\]</span> <span class="math display">\[
\theta_j \sim \mathrm{N}(w_{j}&#39; \lambda, 1)
\]</span></p>
<p>Many aspects of the GRSM are similar to the RSM described earlier. Parameters <span class="math inline">\(\beta_i\)</span>, <span class="math inline">\(\kappa_s\)</span>, <span class="math inline">\(\theta_j\)</span>, and <span class="math inline">\(\lambda\)</span> have the same interpretation, but the GRSM adds a discrimination parameter <span class="math inline">\(\alpha_i\)</span> and constrains the variance of <span class="math inline">\(\theta_j\)</span> to one. The prior <span class="math inline">\(\alpha_i \sim \mathrm{log~N}(1, 1)\)</span> is added, which is weakly informative but assumes positive discriminations. The same priors are placed on <span class="math inline">\(\beta_i\)</span>, <span class="math inline">\(\kappa_s\)</span>, and <span class="math inline">\(\lambda\)</span>, and the same constraints are placed on <span class="math inline">\(\beta_I\)</span> and <span class="math inline">\(\kappa_s\)</span>.</p>
</div>
<div id="stan-code-for-the-generalized-rating-scale-model-with-latent-regression" class="section level2">
<h2><span class="header-section-number">2.2</span> <strong>Stan</strong> code for the generalized rating scale model with latent regression</h2>
<p>The <strong>Stan</strong> code for the GRSM is similar to that for the RSM except for the addition of the discrimination parameters.</p>
<pre class="r"><code># Print the latent regression GRSM model from the edstan package
grsm_latreg_file &lt;- system.file(&quot;extdata/grsm_latent_reg.stan&quot;, 
                                package = &quot;edstan&quot;)
cat(readLines(grsm_latreg_file), sep = &quot;\n&quot;)</code></pre>
<pre><code>functions {
  real rsm(int y, real theta, real beta, vector kappa) {
    vector[rows(kappa) + 1] unsummed;
    vector[rows(kappa) + 1] probs;
    unsummed = append_row(rep_vector(0, 1), theta - beta - kappa);
    probs = softmax(cumulative_sum(unsummed));
    return categorical_lpmf(y + 1 | probs);
  }
  matrix obtain_adjustments(matrix W) {
    real min_w;
    real max_w;
    int minmax_count;
    matrix[2, cols(W)] adj;
    adj[1, 1] = 0;
    adj[2, 1] = 1;
    if(cols(W) &gt; 1) {
      for(k in 2:cols(W)) {                       // remaining columns
        min_w = min(W[1:rows(W), k]);
        max_w = max(W[1:rows(W), k]);
        minmax_count = 0;
        for(j in 1:rows(W))
          minmax_count = minmax_count + W[j,k] == min_w || W[j,k] == max_w;
        if(minmax_count == rows(W)) {       // if column takes only 2 values
          adj[1, k] = mean(W[1:rows(W), k]);
          adj[2, k] = (max_w - min_w);
        } else {                            // if column takes &gt; 2 values
          adj[1, k] = mean(W[1:rows(W), k]);
          adj[2, k] = sd(W[1:rows(W), k]) * 2;
        }
      }
    }
    return adj;
  }
}
data {
  int&lt;lower=1&gt; I;                // # items
  int&lt;lower=1&gt; J;                // # persons
  int&lt;lower=1&gt; N;                // # responses
  int&lt;lower=1,upper=I&gt; ii[N];    // i for n
  int&lt;lower=1,upper=J&gt; jj[N];    // j for n
  int&lt;lower=0&gt; y[N];             // response for n; y in {0 ... m_i}
  int&lt;lower=1&gt; K;                // # person covariates
  matrix[J,K] W;                 // person covariate matrix
}
transformed data {
  int m;                         // # steps
  matrix[2,K] adj;               // values for centering and scaling covariates
  matrix[J,K] W_adj;             // centered and scaled covariates
  m = max(y);
  adj = obtain_adjustments(W);
  for(k in 1:K) for(j in 1:J)
      W_adj[j,k] = (W[j,k] - adj[1,k]) / adj[2,k];
}
parameters {
  vector&lt;lower=0&gt;[I] alpha;
  vector[I-1] beta_free;
  vector[m-1] kappa_free;
  vector[J] theta;
  vector[K] lambda_adj;
}
transformed parameters {
  vector[I] beta;
  vector[m] kappa;
  beta = append_row(beta_free, rep_vector(-1*sum(beta_free), 1));
  kappa = append_row(kappa_free, rep_vector(-1*sum(kappa_free), 1));
}
model {
  alpha ~ lognormal(1, 1);
  target += normal_lpdf(beta | 0, 3);
  target += normal_lpdf(kappa | 0, 3);
  theta ~ normal(W_adj*lambda_adj, 1);
  lambda_adj ~ student_t(3, 0, 1);
  for (n in 1:N)
    target += rsm(y[n], theta[jj[n]] .* alpha[ii[n]], beta[ii[n]], kappa);
}
generated quantities {
  vector[K] lambda;
  lambda[2:K] = lambda_adj[2:K] ./ to_vector(adj[2,2:K]);
  lambda[1] = W_adj[1, 1:K]*lambda_adj[1:K] - W[1, 2:K]*lambda[2:K];
}</code></pre>
</div>
<div id="simulation-for-parameter-recovery-1" class="section level2">
<h2><span class="header-section-number">2.3</span> Simulation for parameter recovery</h2>
<p>The <strong>Stan</strong> model is fit to a simulated dataset to evaluate it’s ability to recover the generating parameter values. The <strong>R</strong> code that follows simulates a dataset conforming to the model. The step difficulties and some other elements are borrowed from the RSM simulation.</p>
<pre class="r"><code># Set alpha, and otherwise use parameters from the previous simulation
alpha &lt;- rep(c(.8, 1.2),  length.out = I)

# Calculate or sample remaining variables and parameters where needed
grsm_theta &lt;-  W %*% matrix(lambda) + rnorm(J, 0, 1)
grsm_y &lt;- numeric(N)
for(n in 1:N) {
  grsm_y[n] &lt;- simulate_response(alpha[ii[n]]*grsm_theta[jj[n]], 
                                 beta[ii[n]], kappa)
}

# Assemble the data list using an edstan function
sim_grsm_list &lt;- irt_data(y = grsm_y, ii = ii, jj = jj, 
                          covariates = as.data.frame(W), 
                          formula = NULL)</code></pre>
<p>The simulated dataset is next fit with <strong>Stan</strong> using <code>irt_stan()</code> from the <strong>edstan</strong> package.</p>
<pre class="r"><code># Fit model to simulated data using an edstan function
sim_grsm_fit &lt;- irt_stan(sim_grsm_list, model = &quot;grsm_latent_reg.stan&quot;,
                         chains = 4, iter = 1000)</code></pre>
<p>The highest value for <span class="math inline">\(\hat R\)</span> was 1.019 for all parameters and the log posterior. The <strong>Stan</strong> model is evaluated in terms of its ability to recover the generating values of the parameters. The R code below prepares a plot in which the points indicate the difference between the posterior means and generating values for the parameters of main interest. This difference is referred to as discrepancy. The lines indicate the 95% poster intervals for the difference, defined as the 2.5th and 97.5th percentiles of the posterior draws. Ideally, (nearly) all the 95% intervals would include zero.</p>
<pre class="r"><code># Get estimated and generating values for wanted parameters
grsm_generating_values &lt;- c(alpha, beta, kappa, lambda)
grsm_estimated_values &lt;- summary(sim_grsm_fit,  
                                 pars = c(&quot;alpha&quot;, &quot;beta&quot;, &quot;kappa&quot;, &quot;lambda&quot;),
                                 probs = c(.025, .975))
grsm_estimated_values &lt;- grsm_estimated_values[[&quot;summary&quot;]]

# Make a data frame of the discrepancies
grsm_discrep &lt;- data.frame(par = rownames(grsm_estimated_values),
                           mean = grsm_estimated_values[, &quot;mean&quot;],
                           p025 = grsm_estimated_values[, &quot;2.5%&quot;],
                           p975 = grsm_estimated_values[, &quot;97.5%&quot;],
                           gen = grsm_generating_values)
grsm_discrep$par &lt;- with(grsm_discrep, factor(par, rev(par)))
grsm_discrep$lower &lt;- with(grsm_discrep, p025 - gen)
grsm_discrep$middle &lt;- with(grsm_discrep, mean - gen)
grsm_discrep$upper &lt;- with(grsm_discrep, p975 - gen)

# Plot the discrepancies
ggplot(grsm_discrep) +
  aes(x = par, y = middle, ymin = lower, ymax = upper) +
  scale_x_discrete() +
  labs(y = &quot;Discrepancy&quot;, x = NULL) +
  geom_abline(intercept = 0, slope = 0, color = &quot;white&quot;) +
  geom_linerange() +
  geom_point(size = 2) +
  theme(panel.grid = element_blank()) +
  coord_flip()</code></pre>
<div class="figure">
<img src="rsm_and_grsm_files/figure-html/sim_grsm_dif-1.png" alt="Discrepancies between estimated and generating parameters. Points indicate the difference between the posterior means and generating values for a parameter, and horizontal lines indicate 95% posterior intervals for the difference. Most of the discrepancies are about zero, indicating that **Stan** successfully recovers the true parameters." width="672" />
<p class="caption">
Discrepancies between estimated and generating parameters. Points indicate the difference between the posterior means and generating values for a parameter, and horizontal lines indicate 95% posterior intervals for the difference. Most of the discrepancies are about zero, indicating that <strong>Stan</strong> successfully recovers the true parameters.
</p>
</div>
</div>
</div>
<div id="example-application" class="section level1">
<h1><span class="header-section-number">3</span> Example application</h1>
<div id="data" class="section level2">
<h2><span class="header-section-number">3.1</span> Data</h2>
<p>The example data are from the Consumer Protection and Perceptions of Science and Technology section of the 1992 Euro-Barometer Survey <span class="citation">(Karlheinzand and Melich 1992)</span>. Because these data do not include person covariates, the latent regression aspect of the model will include an intercept only.</p>
<pre class="r"><code># Convert the example dataset to an integer matrix with values 0 ... 3
M &lt;- matrix(NA, ncol = ncol(Science), nrow = nrow(Science))
for(i in 1:ncol(M)) M[, i] &lt;- as.integer(Science[, i]) - 1</code></pre>
<p>The dataset contains 7 items and 392 persons with no missing responses. The items pertain to attitudes towards science and technology, and responses are scored on a 4-point Likert scale. For example, the text of the first item reads, “Science and technology are making our lives healthier, easier and more comfortable.” The response options are <em>strongly disagree</em>, <em>disagree</em>, <em>agree</em>, and <em>strongly agree</em>.</p>
<p>Before fitting the model, the response frequencies for each item are considered.</p>
<pre class="r"><code># Frequencies for each item
freqs &lt;- t(apply(M, 2, table))
rownames(freqs) &lt;- names(Science)
freqs</code></pre>
<pre><code>##              0   1   2   3
## Comfort      5  32 266  89
## Environment 29  90 145 128
## Work        33  98 206  55
## Future      14  72 210  96
## Technology  18  91 157 126
## Industry    10  47 173 162
## Benefit     21 100 193  78</code></pre>
<p>The data are now formatted into a data list.</p>
<pre class="r"><code># Assemble data list for Stan
ex_list &lt;- irt_data(M)</code></pre>
</div>
<div id="rating-scale-model-results" class="section level2">
<h2><span class="header-section-number">3.2</span> Rating scale model results</h2>
<p>The data list is used to fit the rating scale model.</p>
<pre class="r"><code># Run Stan model
ex_rsm_fit &lt;- irt_stan(ex_list, &quot;rsm_latent_reg.stan&quot;, chains = 4, iter = 300)</code></pre>
<p>As discussed above, convergence of the chains is assessed for every parameter, and also the log posterior density, using <span class="math inline">\(\hat{R}\)</span>.</p>
<pre class="r"><code># Plot of convergence statistics
stan_columns_plot(ex_rsm_fit)</code></pre>
<div class="figure">
<img src="rsm_and_grsm_files/figure-html/ex_rsm_converge-1.png" alt="Convergence statistics ($\hat{R}$) by parameter for the example. All values should be less than 1.1 to infer convergence." width="672" />
<p class="caption">
Convergence statistics (<span class="math inline">\(\hat{R}\)</span>) by parameter for the example. All values should be less than 1.1 to infer convergence.
</p>
</div>
<p>Next we view a summary of the parameter posteriors.</p>
<pre class="r"><code># View table of parameter posteriors
print_irt_stan(ex_rsm_fit, ex_list)</code></pre>
<pre><code>## Inference for Stan model: rsm_latent_reg.
## 4 chains, each with iter=300; warmup=150; thin=1; 
## post-warmup draws per chain=150, total post-warmup draws=600.
##   
##              mean se_mean   sd  2.5%   25%   50%   75% 97.5% n_eff Rhat
## Item 1
##   beta[1]   -0.25    0.00 0.07 -0.38 -0.30 -0.25 -0.21 -0.12   600 1.00
## Item 2
##   beta[2]    0.07    0.00 0.06 -0.06  0.02  0.07  0.11  0.19   600 1.00
## Item 3
##   beta[3]    0.46    0.00 0.06  0.34  0.42  0.46  0.50  0.57   600 1.00
## Item 4
##   beta[4]   -0.01    0.00 0.07 -0.15 -0.05  0.00  0.04  0.13   600 0.99
## Item 5
##   beta[5]   -0.02    0.00 0.06 -0.14 -0.06 -0.02  0.03  0.10   600 0.99
## Item 6
##   beta[6]   -0.52    0.00 0.07 -0.65 -0.56 -0.52 -0.47 -0.38   600 1.00
## Item 7
##   beta[7]    0.27    0.00 0.06  0.15  0.23  0.27  0.31  0.38   553 1.00
## Rating scale step parameters
##   kappa[1]  -1.12    0.01 0.08 -1.27 -1.18 -1.12 -1.07 -0.96   193 1.02
##   kappa[2]  -0.37    0.00 0.06 -0.48 -0.41 -0.37 -0.33 -0.25   411 1.00
##   kappa[3]   1.49    0.01 0.06  1.38  1.46  1.49  1.53  1.60   107 1.03
## Ability distribution
##   lambda[1]  0.72    0.00 0.05  0.63  0.69  0.72  0.75  0.82   105 1.02
##   sigma      0.54    0.01 0.04  0.47  0.51  0.54  0.56  0.63    65 1.05
##   
## Samples were drawn using NUTS(diag_e) at Wed Jun 28 15:20:34 2017.
## For each parameter, n_eff is a crude measure of effective sample size,
## and Rhat is the potential scale reduction factor on split chains (at 
## convergence, Rhat=1).</code></pre>
</div>
<div id="generalized-rating-scale-model-results" class="section level2">
<h2><span class="header-section-number">3.3</span> Generalized rating scale model results</h2>
<p>The data list is used to fit the generalized rating scale model.</p>
<pre class="r"><code># Run Stan model
ex_grsm_fit &lt;- irt_stan(ex_list, &quot;grsm_latent_reg.stan&quot;, chains = 4, iter = 300)</code></pre>
<p>As discussed above, convergence of the chains is assessed for every parameter, and also the log posterior density, using <span class="math inline">\(\hat{R}\)</span>.</p>
<pre class="r"><code># Plot of convergence statistics
stan_columns_plot(ex_grsm_fit)</code></pre>
<div class="figure">
<img src="rsm_and_grsm_files/figure-html/ex_grsm_converge-1.png" alt="Convergence statistics ($\hat{R}$) by parameter for the example. All values should be less than 1.1 to infer convergence." width="672" />
<p class="caption">
Convergence statistics (<span class="math inline">\(\hat{R}\)</span>) by parameter for the example. All values should be less than 1.1 to infer convergence.
</p>
</div>
<p>Next we view a summary of the parameter posteriors.</p>
<pre class="r"><code># View table of parameter posteriors
print_irt_stan(ex_grsm_fit, ex_list)</code></pre>
<pre><code>## Inference for Stan model: grsm_latent_reg.
## 4 chains, each with iter=300; warmup=150; thin=1; 
## post-warmup draws per chain=150, total post-warmup draws=600.
##   
##              mean se_mean   sd  2.5%   25%   50%   75% 97.5% n_eff Rhat
## Item 1
##   alpha[1]   0.29    0.00 0.08  0.14  0.23  0.29  0.35  0.46   600 1.01
##   beta[1]   -0.62    0.00 0.12 -0.86 -0.70 -0.62 -0.54 -0.41   600 1.00
## Item 2
##   alpha[2]   1.32    0.01 0.15  1.06  1.22  1.31  1.42  1.59   144 1.02
##   beta[2]    0.82    0.01 0.15  0.52  0.71  0.81  0.92  1.14   345 1.01
## Item 3
##   alpha[3]   0.13    0.00 0.05  0.05  0.09  0.12  0.16  0.23   600 1.00
##   beta[3]   -0.07    0.00 0.09 -0.23 -0.14 -0.07 -0.01  0.12   600 1.00
## Item 4
##   alpha[4]   0.22    0.00 0.08  0.09  0.17  0.22  0.28  0.38   357 1.00
##   beta[4]   -0.44    0.01 0.11 -0.65 -0.52 -0.44 -0.36 -0.21   428 1.00
## Item 5
##   alpha[5]   1.14    0.01 0.13  0.90  1.05  1.13  1.22  1.43   213 1.02
##   beta[5]    0.54    0.01 0.14  0.26  0.44  0.53  0.63  0.80   227 1.00
## Item 6
##   alpha[6]   1.10    0.01 0.13  0.83  1.03  1.10  1.19  1.35   134 1.02
##   beta[6]   -0.05    0.01 0.13 -0.31 -0.13 -0.05  0.04  0.19   600 1.00
## Item 7
##   alpha[7]   0.22    0.00 0.08  0.09  0.16  0.22  0.27  0.40   258 1.01
##   beta[7]   -0.17    0.00 0.11 -0.38 -0.24 -0.17 -0.09  0.05   600 1.00
## Rating scale step parameters
##   kappa[1]  -1.23    0.00 0.08 -1.40 -1.28 -1.23 -1.17 -1.07   600 1.00
##   kappa[2]  -0.40    0.00 0.06 -0.51 -0.44 -0.39 -0.35 -0.28   600 1.00
##   kappa[3]   1.62    0.00 0.06  1.51  1.58  1.63  1.66  1.74   600 1.00
## Ability distribution
##   lambda[1]  1.26    0.01 0.11  1.08  1.19  1.26  1.33  1.48    59 1.08
##   
## Samples were drawn using NUTS(diag_e) at Wed Jun 28 15:23:17 2017.
## For each parameter, n_eff is a crude measure of effective sample size,
## and Rhat is the potential scale reduction factor on split chains (at 
## convergence, Rhat=1).</code></pre>
</div>
</div>
<div id="references" class="section level1">
<h1><span class="header-section-number">4</span> References</h1>
<!-- This comment causes section to be numbered -->
<div id="refs" class="references">
<div id="ref-andrich1978rating">
<p>Andrich, David. 1978. “A Rating Formulation for Ordered Response Categories.” <em>Psychometrika</em> 43 (4). Springer: 561–73.</p>
</div>
<div id="ref-gelman2008weakly">
<p>Gelman, Andrew, Aleks Jakulin, Maria Grazia Pittau, and Yu-Sung Su. 2008. “A Weakly Informative Default Prior Distribution for Logistic and Other Regression Models.” <em>The Annals of Applied Statistics</em>. JSTOR, 1360–83.</p>
</div>
<div id="ref-Karlheinz1992">
<p>Karlheinzand, R, and A Melich. 1992. <em>Euro-Barometer 38.1: Consumer Protection and Perceptions of Science and Technology</em>. Brussels: INRA (Europe).</p>
</div>
</div>
</div>




</div>

<script>

// add bootstrap table styles to pandoc tables
$(document).ready(function () {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
});

</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
