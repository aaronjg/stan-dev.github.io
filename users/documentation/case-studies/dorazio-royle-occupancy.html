<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />


<meta name="author" content="Bob Carpenter" />


<title>Multiple Species-Site Occupancy Model</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/cerulean.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<link rel="stylesheet"
      href="site_libs/highlight/default.css"
      type="text/css" />
<script src="site_libs/highlight/highlight.js"></script>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs && document.readyState && document.readyState === "complete") {
   window.setTimeout(function() {
      hljs.initHighlighting();
   }, 0);
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>


</head>

<body>

<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
button.code-folding-btn:focus {
  outline: none;
}
</style>


<div class="container-fluid main-container">

<!-- tabsets -->
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});
</script>

<!-- code folding -->






<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Multiple Species-Site Occupancy Model</h1>
<h4 class="author"><em>Bob Carpenter</em></h4>
<h4 class="date"><em>April 19, 2015 (revised March 21, 2017)</em></h4>

</div>


<p>In the following paper, Dorazio et al. provide a hierarchical occupancy model for “estimating species richness and accumulation by forming these community-level attributes as functions of model-based estimators of species occurence while accounting for imperfect detection of individual species.”</p>
<blockquote>
Dorazio, R. M., Royle, J. A., Söderström, B., &amp; Glimskär, A. (2006). <a href="http://www.uvm.edu/rsenr/vtcfwru/spreadsheets/occupancy/Occupancy%20Exercises/Exercise15/Dorazio_et_al_2006.pdf">Estimating species richness and accumulation by modeling species occurrence and detectability</a>. <i>Ecology</i> <b>87</b>(4), 842-854.
</blockquote>
<p>They apply their model to estimating total numbers of butterfly species (and of birds, with a similar format to the data).</p>
<p>This <a href="http://yihui.name/knitr/">knitr</a> document contains all that you need to replicate Dorazio et al.’s statistical analysis of butterfly species. The model is coded and statistical inference carried out using the Bayesian inference package <a href="http://mc-stan.org">RStan</a>. A great follow-on exercise would be to code up more of the models from <a href="http://www.mbr-pwrc.usgs.gov/pubanalysis/roylebook/chapters.htm">Dorazio and Royle’s book</a> in Stan.</p>
<div id="data" class="section level2">
<h2>Data</h2>
<p>The data consists of an the observation of butterfly species in July 1997 at “grazed seminatural grasslands located in south-central Sweden…Twenty grasslands thought to be representative of the region were selected for sampling”.</p>
<p>The data consists of the following variables:</p>
<ul>
<li><p><span class="math inline">\(n\)</span>: distinct butterfly species detected (28)</p></li>
<li><p><span class="math inline">\(J\)</span>: distinct sites visited (20)</p></li>
<li><p><span class="math inline">\(K\)</span>: visits to each site (18)</p></li>
<li><p><span class="math inline">\(x\)</span>: <span class="math inline">\(n \times J\)</span> matrix where <span class="math inline">\(x_{i,j} \in 1{:}K\)</span> is the number of visits in which species <span class="math inline">\(i\)</span> was observed at site <span class="math inline">\(j\)</span></p></li>
<li><p><span class="math inline">\(S\)</span>: size of supercommunity out of which community is drawn (50)</p></li>
</ul>
<p>The supercommunity size parameter <span class="math inline">\(S\)</span> is just required to be large enough to encompass all possible species that might be present; it will affect the estimation of various model parameters, but not the derived quantities of interest such as the estimated total number of species available at a site.</p>
<p>Reading the data in requires a web connection to the publisher’s web site:</p>
<pre class="r"><code>x_csv &lt;- read.csv(&quot;http://esapubs.org/archive/ecol/E087/050/butterflyData.txt&quot;);
n &lt;- dim(x_csv)[1];
J &lt;- dim(x_csv)[2];
x &lt;- matrix(NA, n, J)
for (i in 1:n) {
  for (j in 1:J) {
    x[i,j] &lt;- x_csv[i,j];
  }
}
K &lt;- 18;   # read from paper, figure 5
S &lt;- 50;   # more than adequate judging from plot in figure 6
head(x_csv);</code></pre>
<pre><code>##                       X1 X2 X3 X4 X5 X6 X7 X8 X9 X10 X11 X12 X13 X14 X15
## Aglais.urticae         0  0  1  0  1  2  1  0  1   1   2   0   3   2   1
## Aphantopus.hyperantus 14 10 13 15  3  9  7 17  1  11  11  15  15   6   0
## Argynnis.paphia        0  0  2  4  1  1  0  5  0   0   0   2   2   0   0
## Aricia.artaxerxes      0  1  0  4  0  0  0  0  0   2   2   0   0   0   0
## Aricia.eumedon         0  3  1  4  0  0  0  2  0   0   0   0   0   0   0
## Brenthis.ino           0  1  1  1  0  0  1  1  0   0   3   0   0   0   0
##                       X16 X17 X18 X19 X20
## Aglais.urticae          1   1   0   2   0
## Aphantopus.hyperantus  10  15   5  11   6
## Argynnis.paphia         0   1   3   1   1
## Aricia.artaxerxes       2   1   0   0   0
## Aricia.eumedon          0   0   0   0   0
## Brenthis.ino            0   0   1   0   0</code></pre>
<p>The first thing Dorazio et al. do is plot the data itself (figure 5 of their paper). This requires the R packages ggplot2 and reshape2, (both of which may be installed from CRAN).</p>
<pre class="r"><code>library(ggplot2);
library(reshape2);
df_x &lt;- melt(x);
colnames(df_x)[1] &lt;- &quot;species&quot;;
colnames(df_x)[2] &lt;- &quot;site&quot;;
colnames(df_x)[3] &lt;- &quot;detections&quot;;

head(df_x);</code></pre>
<pre><code>##   species site detections
## 1       1    1          0
## 2       2    1         14
## 3       3    1          0
## 4       4    1          0
## 5       5    1          0
## 6       6    1          0</code></pre>
<pre class="r"><code>detections_heatmap_plot &lt;-
  ggplot(df_x, aes(site, species)) +
  geom_tile(aes(fill = detections), colour = &quot;white&quot;) +
  scale_fill_gradient(low = &quot;white&quot;, high = &quot;black&quot;) +
  labs(x = &quot;site number&quot;, y = &quot;species number&quot;) +
  scale_x_discrete(expand = c(0, -5), breaks=(5 * (1:4))) +
  scale_y_discrete(expand = c(0, -5), breaks=(5 * (1:5))) +
  ggtitle(&quot;Detections of Species at Sites over Visits&quot;);

plot(detections_heatmap_plot);</code></pre>
<p><img src="dorazio-et-al-knitr_files/figure-html/unnamed-chunk-2-1.png" width="672" /></p>
<p>Unlike Dorazio et al.’s original plot, this version does not reorder the species by total detections.</p>
</div>
<div id="statistical-model" class="section level2">
<h2>Statistical Model</h2>
<div id="parameters" class="section level3">
<h3>Parameters</h3>
<p>The model involves parameters for the site (here the sites are considered exchangeable and considered to share a single parameter) that determine species occupancy and detectability.</p>
<ul>
<li><p><span class="math inline">\(\alpha\)</span> : site-level occupancy (logit scaled)</p></li>
<li><p><span class="math inline">\(\beta\)</span> : site-level detection (logit scaled)</p></li>
</ul>
<p>There is a single parameter for the probability of a species being in the region:</p>
<ul>
<li><span class="math inline">\(\Omega \in (0,1)\)</span>: availability of species</li>
</ul>
<p>Then for each species <span class="math inline">\(i\)</span>, there are a pair of parameters for species-specific occupancy and detection</p>
<ul>
<li><p><span class="math inline">\(u_i\)</span> : species-level occupancy (logit scaled)</p></li>
<li><p><span class="math inline">\(v_i\)</span> : species-level detection (logit scaled)</p></li>
</ul>
<p>These species-level effects are given a hierarchical multivariate normal prior with zero mean and covariance matrix parameterized by three scalars,</p>
<ul>
<li><span class="math inline">\(\sigma_u\)</span> : std deviation of species occupancy</li>
<li><span class="math inline">\(\sigma_v\)</span> : std deviation of species detection</li>
<li><span class="math inline">\(\rho_{uv}\)</span> : correlation of species occupancy and detection</li>
</ul>
<p>so that the covariance matrix for the prior on <span class="math inline">\((u,v)\)</span> pairs is defined as</p>
<p><span class="math inline">\(\Sigma = \left[  \begin{array}{cc}  \sigma_u^2 &amp; \sigma_u \sigma_v \rho_{uv} \\  \sigma_u \sigma_v \rho_{uv} &amp; \sigma_v^2  \end{array}  \right]\)</span></p>
</div>
<div id="priors" class="section level3">
<h3>Priors</h3>
<p>Rather than using Dorazio et al.’s exact diffuse priors, we follow the recommendations given in the Stan manual, and formulate priors as</p>
<ul>
<li><p><span class="math inline">\(\alpha, \beta \sim \mbox{Cauchy}(0, 2.5)\)</span></p></li>
<li><p><span class="math inline">\(\sigma_u, \sigma_v \sim \mbox{Cauchy}(0, 2.5)\)</span></p></li>
<li><p><span class="math inline">\((\rho_{uv} + 1) / 2 \sim \mbox{Beta}(2,2)\)</span></p></li>
<li><p><span class="math inline">\((u_i, v_i) \sim \mbox{Normal}(0, \Sigma)\)</span></p></li>
<li><p><span class="math inline">\(\Omega \sim \mbox{Beta}(2,2)\)</span></p></li>
</ul>
<p>Although we did not perform any prior sensitivity analysis, the results from the above weakly informative priors are in-line with what Dorazio et al. found with diffuse conjugate inverse gamma priors on <span class="math inline">\(\sigma_u, \sigma_v\)</span>, diffuse normal priors on <span class="math inline">\(\alpha, \beta\)</span>, and uniform priors on <span class="math inline">\(\Omega\)</span> and <span class="math inline">\(\rho_{uv}\)</span>.</p>
</div>
<div id="latent-parameters" class="section level3">
<h3>Latent Parameters</h3>
<p>Dorazio et al. formulate the likelihood for <span class="math inline">\(x_{i,j}\)</span> in terms of two discrete variables,</p>
<ul>
<li><p><span class="math inline">\(z_{i,j} = 1\)</span> if species <span class="math inline">\(i\)</span> is present at site <span class="math inline">\(j\)</span></p></li>
<li><p><span class="math inline">\(w_i = 1\)</span> if species <span class="math inline">\(i\)</span> in supercommunity is available</p></li>
</ul>
<p>By definition, for <span class="math inline">\(i \in (n+1){:}S\)</span>, <span class="math inline">\(x_{i,j} = 0\)</span>, because no members of species <span class="math inline">\(i\)</span> was detected for <span class="math inline">\(i &gt; n\)</span>. Also by definition, <span class="math inline">\(w_i = 1\)</span> for <span class="math inline">\(i \leq n\)</span>, because a species must be available if it was detected, whereas <span class="math inline">\(w_i\)</span> for <span class="math inline">\(i &gt; n\)</span> is a latent parameter. The availability of a species from the supercommunity is modeled by</p>
<ul>
<li><span class="math inline">\(w_i \sim \mbox{Bernoulli}(\Omega)\)</span>.</li>
</ul>
<p>The site-level availability is modeled by</p>
<ul>
<li><span class="math inline">\(z_{i,j} \sim \mbox{Bernoulli}(\psi_i)\)</span>,</li>
</ul>
<p>where <span class="math inline">\(\psi_i = \mbox{logit}^{-1}(u_i + \alpha)\)</span>. Dorazio et al. use two indexes, writing <span class="math inline">\(\psi_{i,j}\)</span>, but for their analyses assume <span class="math inline">\(\psi_{i,j} = \psi_{i,j&#39;}\)</span> for all <span class="math inline">\(j, j&#39;\)</span>, allowing this note to simplify <span class="math inline">\(\psi\)</span> to a vector.</p>
</div>
<div id="likelihood" class="section level3">
<h3>Likelihood</h3>
<p>The likelihood for the observed data is defined by marginalizing over the unobserved latent parameters (by “summing out” using the law of total probability), with the number of visits to site <span class="math inline">\(j\)</span> on which species <span class="math inline">\(i\)</span> was detected is given by equation (2) in Dorazio et al.’s paper, which we rewrite using sampling notation as</p>
<ul>
<li><span class="math inline">\(x_{i,j} \sim \mbox{Binomial}(K, z_{i,j} \theta_i)\)</span>,</li>
</ul>
<p>where the detection probability is <span class="math inline">\(\theta_i = \mbox{logit}^{-1}(v_i + \beta)\)</span>. (As with <span class="math inline">\(\psi\)</span>, this note simplifies Dorazio et al.’s notation by treating <span class="math inline">\(\theta\)</span> as a vector.)</p>
<p>Note that if <span class="math inline">\(z_{i,j} = 0\)</span>, then species <span class="math inline">\(i\)</span> is not present at site <span class="math inline">\(j\)</span> and hence <span class="math inline">\(x_{i,j} = 0\)</span> by definition. As pointed out in the paper, “if species <span class="math inline">\(i\)</span> is not detected at site <span class="math inline">\(j\)</span> (i.e., <span class="math inline">\(x_{i,j} = 0\)</span>), species <span class="math inline">\(i\)</span> is either absent (with probability <span class="math inline">\(1 - \psi_i\)</span>) or present but undetected (with probability <span class="math inline">\(\psi_i (1 - \theta_i)^K\)</span>).”</p>
<p>Marginalizing the <span class="math inline">\(z_{i,j}\)</span> from the above gives the following for <span class="math inline">\(i \in 1{:}n\)</span>, which is explicitly conditioned on the species being available <span class="math inline">\(w_i = 1\)</span>,</p>
<p><span class="math inline">\(p(x_{i,j} \, | \, \theta_i, \psi_i) = \mbox{Bernoulli}(1 \, | \, \psi_i) \times \mbox{Binomial}(x_{i,j} \, | \, K, \theta_i)  + \mbox{Bernoulli}(0 \, | \, \psi_i) \times \mbox{I}(x_{i,j} = 0)\)</span></p>
<p>The Stan model will exploit the fact that if <span class="math inline">\(x_{i,j} &gt; 0\)</span>, the second term representing non-occurrence drops out.</p>
<p>The <span class="math inline">\(w_i = 1\)</span> enters the likelihood computation as <span class="math inline">\(\mbox{Bernoulli}(1 \, | \, \Omega)\)</span> when looking at the entire vector <span class="math inline">\(x_i = x_{i,1}, \ldots, x_{i,n}\)</span> of site-detection counts for detected species <span class="math inline">\(i \in 1{:}n\)</span>, as</p>
<p><span class="math inline">\(p(x_i \, | \, \theta_i, \psi_i, \Omega) = \mbox{Bernoulli}(1 \, | \, \Omega) \times \prod_{j=1}^J p(x_{i,j} \, | \, \theta_i, \psi_i)\)</span></p>
<p>Expanding out the nested probability function gives the final form of</p>
<p><span class="math inline">\(p(x_i \, | \, \theta_i, \psi_i, \Omega) = \mbox{Bernoulli}(1 \, | \, \Omega)  \times \prod_{j=1}^J  \left(  \mbox{Bernoulli}(1 \, | \, \psi_i) \times \mbox{Binomial}(x_{i,j} \, | \, K, \theta_i)  + \mbox{Bernoulli}(0 \, | \, \psi_i) \times \mbox{I}(x_{i,j} = 0)  \right)\)</span></p>
<p>The <span class="math inline">\(1\)</span> built into the Bernoulli is because we know that <span class="math inline">\(x_{i,j} &gt; 0\)</span> for at least one <span class="math inline">\(j\)</span> and hence we know species <span class="math inline">\(i\)</span> is available.</p>
<p>The last step is marginalizing out the <span class="math inline">\(w_i\)</span> for the undetected species <span class="math inline">\(i \in (n+1){:}S\)</span>, for which we know <span class="math inline">\(x_{i,j} = 0\)</span>, giving</p>
<p><span class="math inline">\(p(x_i \, | \, \Omega, \psi_i, \theta_i) = \mbox{Bernoulli}(0 \, | \, \Omega)  + \mbox{Bernoulli}(1 \, | \, \Omega)  \times \prod_{j=1}^J p(x_{i,j} \, | \, \theta_i, \psi_i)\)</span>.</p>
<p>where the final term is defined as for the formula conditioning on <span class="math inline">\(w_i = 1\)</span> above, knowing that <span class="math inline">\(x_{i,j} = 0\)</span> because <span class="math inline">\(i &gt; n\)</span>, resulting in the full joint likelihood of <span class="math inline">\(x_i = x_{i,1}, \ldots, x_{i,J}\)</span> for the case where <span class="math inline">\(i &gt; n\)</span> of</p>
<p><span class="math inline">\(p(x_i \, | \, \Omega, \psi_i, \theta_i)  = \begin{array}[t]{l}  \mbox{Bernoulli}(0 \, | \, \Omega)  \\ \mbox{ }  + \mbox{Bernoulli}(1 \, | \, \Omega)  \times \prod_{j=1}^J  \big(  \mbox{Bernoulli}(1 \, | \, \psi_i) \times \mbox{Binomial}(x_{i,j} \, | \, K, \theta_i)  + \mbox{Bernoulli}(0 \, | \, \psi_i)  \big)  \end{array}\)</span></p>
</div>
</div>
<div id="stan-program" class="section level2">
<h2>Stan Program</h2>
<p>With the data, parameters, likelihood, and prior in hand, the Stan program defines the log density following the steps given above for marginalizing out the discrete parameters.</p>
<pre class="r"><code>stan_program &lt;- &quot;
functions {
  matrix cov_matrix_2d(vector sigma, real rho) {
    matrix[2,2] Sigma;
    Sigma[1,1] = square(sigma[1]);
    Sigma[2,2] = square(sigma[2]);
    Sigma[1,2] = sigma[1] * sigma[2] * rho;
    Sigma[2,1] = Sigma[1,2];
    return Sigma;
  }

  real lp_observed(int x, int K, real logit_psi, real logit_theta) {
    return log_inv_logit(logit_psi)
      + binomial_logit_lpmf(x | K, logit_theta);
  }

  real lp_unobserved(int K, real logit_psi, real logit_theta) {
    return log_sum_exp(lp_observed(0, K, logit_psi, logit_theta),
                       log1m_inv_logit(logit_psi));
  }

  real lp_never_observed(int J, int K, real logit_psi, real logit_theta,
                         real Omega) {
      real lp_unavailable = bernoulli_lpmf(0 | Omega);
      real lp_available = bernoulli_lpmf(1 | Omega)
        + J * lp_unobserved(K, logit_psi, logit_theta);
      return log_sum_exp(lp_unavailable, lp_available);
    }
}
data {
  int&lt;lower=1&gt; J;  // sites within region
  int&lt;lower=1&gt; K;  // visits to sites
  int&lt;lower=1&gt; n;  // observed species
  int&lt;lower=0, upper=K&gt; x[n,J];  // visits when species i was detected at site j
  int&lt;lower=n&gt; S;  // superpopulation size
}
parameters {
  real alpha;  //  site-level occupancy
  real beta;   //  site-level detection
  real&lt;lower=0, upper=1&gt; Omega;  // availability of species

  real&lt;lower=-1,upper=1&gt; rho_uv;  // correlation of (occupancy, detection)
  vector&lt;lower=0&gt;[2] sigma_uv;    // sd of (occupancy, detection)
  vector[2] uv[S];                // species-level (occupancy, detection)
}
transformed parameters {
  vector[S] logit_psi;    // log odds  of occurrence
  vector[S] logit_theta;  // log odds of detection
  for (i in 1:S)
    logit_psi[i] = uv[i,1] + alpha;
  for (i in 1:S)
    logit_theta[i] = uv[i,2] + beta;
}
model {
  // priors
  alpha ~ cauchy(0, 2.5);
  beta ~ cauchy(0, 2.5);
  sigma_uv ~ cauchy(0, 2.5);
  (rho_uv + 1) / 2 ~ beta(2, 2);
  uv ~ multi_normal(rep_vector(0, 2), cov_matrix_2d(sigma_uv, rho_uv));
  Omega ~ beta(2,2);

  // likelihood
  for (i in 1:n) {
    1 ~ bernoulli(Omega); // observed, so available
    for (j in 1:J) {
      if (x[i,j] &gt; 0)
        target += lp_observed(x[i,j], K, logit_psi[i], logit_theta[i]);
      else
        target += lp_unobserved(K, logit_psi[i], logit_theta[i]);
    }
  }
  for (i in (n + 1):S)
    target += lp_never_observed(J, K, logit_psi[i], logit_theta[i], Omega);
}
generated quantities {
  real&lt;lower=0,upper=S&gt; E_N = S * Omega; // model-based expectation species
  int&lt;lower=0,upper=S&gt; E_N_2;  // posterior simulated species
  vector[2] sim_uv;
  real logit_psi_sim;
  real logit_theta_sim;

  E_N_2 = n;
  for (i in (n+1):S) {
    real lp_unavailable = bernoulli_lpmf(0 | Omega);
    real lp_available = bernoulli_lpmf(1 | Omega)
      + J * lp_unobserved(K, logit_psi[i], logit_theta[i]);
    real Pr_available = exp(lp_available
                            - log_sum_exp(lp_unavailable, lp_available));
    E_N_2 = E_N_2 + bernoulli_rng(Pr_available);
  }

  sim_uv = multi_normal_rng(rep_vector(0,2),
                             cov_matrix_2d(sigma_uv, rho_uv));
  logit_psi_sim = alpha + sim_uv[1];
  logit_theta_sim = beta + sim_uv[2];
}
&quot;;</code></pre>
<p>There are several helper functions defined:</p>
<ul>
<li><p><code>cov_matrix_2d()</code>: constructs a <span class="math inline">\(2 \times 2\)</span> covariance matrix from the standard deviations and correlation</p></li>
<li><p><code>lp_observed()</code>: log likelihood function for case where <span class="math inline">\(x_{i,j} &gt; 0\)</span> (entails <span class="math inline">\(i \leq n\)</span>)</p></li>
<li><p><code>lp_unobserved()</code>: log likelihood function for case where <span class="math inline">\(x_{i,j} = 0\)</span></p></li>
<li><p><code>lp_never_observed()</code>: log likelihood function for case where the entire vector <span class="math inline">\(x_i = 0\)</span> (entails <span class="math inline">\(i &gt; n\)</span>)</p></li>
</ul>
<p>These log likelihood definitions take advantage of the fact that <span class="math inline">\(\psi\)</span> and <span class="math inline">\(\theta\)</span> do not vary by site, allowing scalar arguments to the functions and the use of <span class="math inline">\(J\)</span> as a multiplicand in the definition of <code>lp_never_observed()</code>.</p>
<p>The data and parameters are declared with appropriate constraints based on their restrictions.</p>
<p>The transformed parameters block defines the logit-scaled versions of <span class="math inline">\(\psi\)</span> and <span class="math inline">\(\theta\)</span> as vectors, again noting they do not vary by site in this model.</p>
<p>The model block defines the priors directly as specified. The expression <code>rep_vector(0, 2)</code> provides a zero-vector for the mean of the multivariate normal prior.</p>
<p>The model block then defines the likelihood by separating out the cases for <span class="math inline">\(i \leq n\)</span> and the cases <span class="math inline">\(i &gt; n\)</span>. The former also branches using a conditional on <code>x[i,j] &gt; 0</code> to determine whether to use the simplified form of log likelihood for the unobserved case. Otherwise, the likelihood is just called directly. The <code>increment_log_prob()</code> function is used to add directly to the log density defined by the Stan model block.</p>
<p>The generated quantities block performs three calculations. The generated quantities block is executed once per iteration, calculating the variables declared at the top of the block using the parameter values for the iteration. This provides full Bayesian inference via MCMC for the following variables defined in the generated quantities block.</p>
<ul>
<li><p><code>E_N</code>, the expectation of <span class="math inline">\(N\)</span> using the simple formula <span class="math inline">\(S \times \Omega\)</span> suggested in the Dorazio et al. paper.</p></li>
<li><p><code>E_N_2</code>, which we assume is how Dorazio et al. actually estimated species occupancy. This is carried out by reconstructing the expectations of the <span class="math inline">\(w_i\)</span> in the posterior for <span class="math inline">\(i &gt; n\)</span> and adding the resulting sum to <span class="math inline">\(n\)</span>, because we know <span class="math inline">\(w_i = 1\)</span> for <span class="math inline">\(i \leq n\)</span>. The log likelihood of availability and unavailability is calculated for each <span class="math inline">\(i &gt; n\)</span>, then normalized to define <code>Pr_available</code>, which is the posterior expectation of <span class="math inline">\(w_i\)</span> for species never detected for the parameter values being used.</p></li>
<li><p>The third generated quantities is a set of simulated <span class="math inline">\((u,v)\)</span> pairs for a new species, along with the logit-scaled <span class="math inline">\(\psi\)</span> and <span class="math inline">\(\theta\)</span> variables. These are used for posterior predictive checking to see if the actual species are distributed as characterized by their prior.</p></li>
</ul>
</div>
<div id="fitting-the-model" class="section level2">
<h2>Fitting the Model</h2>
<p>Next up, we fit the model by running Stan and then printing the fit object producted. The control parameters are provided to avoid divergence of the numerical simulations during warmup. The initial stepsize is set to 0.01 instead of its default 1, which causes the Hamiltonian dynamics to be evaluated using smaller steps at the expense of some computaiton time. The other control parameter is the target acceptance rate (a complicated notion with the no-U-turn sampler used by Stan), which is set to 0.95, which is higher than its default value of 0.8, so that the target step size will be lower and the floating-point arithmetic more stable. Together, these cause Stan to run a bit more stably but at about half the speed of the default settings.</p>
<p>A total of four Markov chains are simulated, each for 5000 iterations, with the default of 2500 warmup iterations being used for adaptation and discarded to produce the final sample, which will consist of the second-half of each chain, or a total of 10,000 draws. The width of the print is increased before printing the fit because it’s rather wide.</p>
<div id="running-the-model" class="section level3">
<h3>Running the Model</h3>
<p>The model is fit by loading the RStan library, then calling the <code>stan()</code> function given the program, names of the data variables in the global environment, a control specification for Stan (optional), and a number of chains, iterations per chain, and random seed (the seed is also optional but will guarantee the same results across runs if provided).</p>
<pre class="r"><code>library(rstan);
fit &lt;- stan(model_code=stan_program, data=c(&quot;x&quot;, &quot;n&quot;, &quot;J&quot;, &quot;K&quot;, &quot;S&quot;),
            control=list(stepsize=0.01, adapt_delta=0.95),
            chains=4, iter=5000, refresh=0, seed=12345);</code></pre>
<pre><code>## Warning: There were 4 chains where the estimated Bayesian Fraction of Missing Information was low. See
## http://mc-stan.org/misc/warnings.html#bfmi-low</code></pre>
<pre><code>## Warning: Examine the pairs() plot to diagnose sampling problems</code></pre>
<p>Setting <code>refresh=0</code> removes the output updates during warmup and sampling.</p>
</div>
<div id="printing-the-fitted-parameters" class="section level3">
<h3>Printing the Fitted Parameters</h3>
<p>The fit object can be directly printed in RStan (after widening the default output number of columns).</p>
<pre class="r"><code>options(width=&quot;120&quot;)
print(fit, c(&quot;alpha&quot;, &quot;beta&quot;, &quot;Omega&quot;, &quot;sigma_uv&quot;, &quot;rho_uv&quot;, &quot;E_N&quot;, &quot;E_N_2&quot;, &quot;lp__&quot;));</code></pre>
<pre><code>## Inference for Stan model: ff975a7e121ef7b489369ef2eb311654.
## 4 chains, each with iter=5000; warmup=2500; thin=1; 
## post-warmup draws per chain=2500, total post-warmup draws=10000.
## 
##                 mean se_mean    sd     2.5%      25%      50%      75%    97.5% n_eff Rhat
## alpha           1.23    0.01  0.28     0.67     1.05     1.23     1.41     1.79  1976 1.00
## beta           -1.88    0.01  0.24    -2.38    -2.03    -1.87    -1.72    -1.44  1053 1.00
## Omega           0.56    0.00  0.07     0.43     0.52     0.56     0.61     0.70 10000 1.00
## sigma_uv[1]     1.05    0.01  0.30     0.53     0.85     1.02     1.22     1.70   963 1.01
## sigma_uv[2]     1.19    0.00  0.21     0.86     1.05     1.17     1.31     1.68  1842 1.00
## rho_uv          0.70    0.01  0.19     0.23     0.60     0.74     0.84     0.95   639 1.01
## E_N            28.23    0.03  3.39    21.56    25.94    28.25    30.56    34.82 10000 1.00
## E_N_2          28.52    0.02  0.93    28.00    28.00    28.00    29.00    31.00  2072 1.00
## lp__        -1158.52    0.97 19.69 -1194.86 -1171.76 -1159.49 -1146.22 -1117.67   413 1.01
## 
## Samples were drawn using NUTS(diag_e) at Tue Jun 27 21:01:41 2017.
## For each parameter, n_eff is a crude measure of effective sample size,
## and Rhat is the potential scale reduction factor on split chains (at 
## convergence, Rhat=1).</code></pre>
<p>An explicit list of parameters to print is provided to suppress the printing of the parameters <code>u</code> and <code>v</code> and the transformed parameters <code>logit_psi</code> and <code>logit_theta</code>.</p>
</div>
<div id="inspecting-traceplots-for-mixing" class="section level3">
<h3>Inspecting Traceplots for Mixing</h3>
<p>The traceplots can be shown for some of the parameters (incuding one <span class="math inline">\((u,v)\)</span> pair for a detected species and one for an undetected species) and the log density (up to a constant).</p>
<pre class="r"><code>traceplot(fit,
          c(&quot;Omega&quot;, &quot;alpha&quot;, &quot;beta&quot;, &quot;sigma_uv&quot;, &quot;rho_uv&quot;,
            &quot;uv[1,1]&quot;, &quot;uv[1,2]&quot;, &quot;uv[30,1]&quot;, &quot;uv[30,2]&quot;,
            &quot;lp__&quot;),
          inc_warmup=FALSE) +
  coord_cartesian(xlim = c(3001,3200)) +
  scale_x_continuous(breaks=c(3000, 3100, 3200))</code></pre>
<p><img src="dorazio-et-al-knitr_files/figure-html/unnamed-chunk-6-1.png" width="672" /></p>
<p>This only shows 200 iterations so the speed of the mixing can be visualized. It shows that the parameters mix quite well after warmup, which is what leads to high numbes of effective samples (<code>n_eff</code>) relative to the number of iterations and mixing diagnostic (<code>Rhat</code>) being close to 1. To get a sense of the speed of convergence, the following shows the traceplot for the first 50 warmup iterations for the total model log density, showing Stan converging rapdily from four different initial starting points of widely varying density. As seen in this example, Stan is quite effective at converging from diffuse random initializations of the parameters.</p>
<pre class="r"><code>traceplot(fit, &quot;lp__&quot;, inc_warmup=TRUE) +
  coord_cartesian(xlim = c(1, 50));</code></pre>
<p><img src="dorazio-et-al-knitr_files/figure-html/unnamed-chunk-7-1.png" width="672" /></p>
<p>This time, the warmup was included in the traceplot and only the first 50 iterations shown.</p>
</div>
<div id="pairs-plot-and-posterior-covariance-of-parameters" class="section level3">
<h3>Pairs Plot and Posterior Covariance of Parameters</h3>
<p>Stan also provides a built-in pairs plot, which by default puts half the chains above the diagonal and half below, and can also be specialized to a subset of the parameters.</p>
<pre class="r"><code># pairs(fit, pars = c(&quot;Omega&quot;, &quot;alpha&quot;, &quot;beta&quot;, &quot;sigma_uv&quot;, &quot;rho_uv&quot;, &quot;lp__&quot;));</code></pre>
<p>This plot is not turned on in the output because it produces a huge image with this many draws (there is a <code>condition</code> argument to <code>pairs()</code> that can be used to trim the input or reorganize what is printed above and below the diagonal based on user-defined conditions.</p>
</div>
<div id="estimated-number-of-species" class="section level3">
<h3>Estimated Number of Species</h3>
<p>One of the key estimands of interest in the Dorazio et al. paper is the total number of species available. How this is computed was already discussed above in the model section. To recreate figure 6 from the Dorazio et al. paper, which plots the posterior estimates for total species, the following ggplot2 code suffices. Before the plot is run, the simulations are extracted from the fit object and used to build up the frequency to be plotted.</p>
<pre class="r"><code>sims &lt;- extract(fit);

freq &lt;- rep(0,S);
N &lt;- sims$E_N_2
for (i in 1:length(N))
  freq[N[i]] &lt;- freq[N[i]] + 1;
freq &lt;- freq / length(N);

dat &lt;- data.frame(freq);
dat &lt;- cbind(1:S, dat);
colnames(dat)[1] &lt;- &quot;N&quot;;
dat &lt;- dat[28:38, ];

N_bar_plot &lt;-
  ggplot(data=dat, aes(x=N, y=freq)) +
  geom_bar(stat=&quot;identity&quot;) +
  scale_x_continuous(name=&quot;butteryfly species (N)&quot;,
                     breaks=c(28,30,32,34,36,38)) +
  scale_y_continuous(name=&quot;relative frequency&quot;,
                     breaks=(0.1 * (0:6))) +
  ggtitle(&quot;Posterior: Number of Species (N)&quot;);

plot(N_bar_plot);</code></pre>
<p><img src="dorazio-et-al-knitr_files/figure-html/unnamed-chunk-9-1.png" width="672" /></p>
<p>The plot confirms that the choice of <span class="math inline">\(S = 50\)</span> is adequate; had the posterior mass extended up to 50, we would need to rerun the analysis with a higher value.</p>
</div>
<div id="posterior-probabilities-of-occurrence-and-detection" class="section level3">
<h3>Posterior Probabilities of Occurrence and Detection</h3>
<p>The following plots the posterior density of <span class="math inline">\(\psi\)</span> (probability of occurrence) on the original probability scale, which is the left-side plot in figure 7 in the Dorazio et al. paper; the inverse logit function is defined to do the transform from the logit-scaled parameters.</p>
<pre class="r"><code>ilogit &lt;- function(u) { return(1 / (1 + exp(-u))); }

df_psi_theta &lt;- data.frame(cbind(ilogit(sims$logit_psi_sim),
                                 ilogit(sims$logit_theta_sim)));
colnames(df_psi_theta)[1] &lt;- &quot;psi&quot;;
colnames(df_psi_theta)[2] &lt;- &quot;theta&quot;;

psi_density_plot &lt;-
  ggplot(df_psi_theta, aes(x=psi)) +
  geom_line(stat = &quot;density&quot;, adjust=1) +
  scale_x_continuous(name=&quot;probability of occurrence&quot;,
                     limits=c(0,1), breaks=(0.2 * (0:5))) +
  scale_y_continuous(name=&quot;probability density&quot;,
                     limits=c(0,4.5), breaks=(0:4)) +
  ggtitle(&quot;Posterior: Occurrence (psi)&quot;);

plot(psi_density_plot);</code></pre>
<p><img src="dorazio-et-al-knitr_files/figure-html/unnamed-chunk-10-1.png" width="672" /></p>
<p>To reproduce the right-hand side plot in figure 7 from the paper, the posterior for <span class="math inline">\(\theta\)</span> (probability of detection) is plotted as follows, using the same data frame as for the previous plot.</p>
<pre class="r"><code>theta_density_plot &lt;-
  ggplot(df_psi_theta, aes(x=theta)) +
  geom_line(stat = &quot;density&quot;, adjust=1) +
  scale_x_continuous(name=&quot;probability of detection&quot;,
    limits=c(0,1), breaks=(0.2 * (0:5))) +
  scale_y_continuous(name=&quot;probability density&quot;,
                     limits=c(0,4.5), breaks=(0:4)) +
  ggtitle(&quot;Posterior: Detection (theta)&quot;);

plot(theta_density_plot);</code></pre>
<p><img src="dorazio-et-al-knitr_files/figure-html/unnamed-chunk-11-1.png" width="672" /></p>
</div>
<div id="site-level-parameter-posterior" class="section level3">
<h3>Site-Level Parameter Posterior</h3>
<p>Although it duplicates the effort of the <code>pairs()</code> plot given above, here is a direct plot of just the posterior of the <span class="math inline">\(\alpha\)</span> (site-level occupancy) and <span class="math inline">\(\beta\)</span> (site-level detection) parameters. The posterior draws are subsetted so that only 500 draws are printed. These draws are random across iterations and chains because Stan’s <code>extract()</code> function permutes the draws by default.</p>
<pre class="r"><code>fit_ss &lt;- extract(fit);

df_alpha_beta &lt;- data.frame(fit_ss$alpha, fit_ss$beta);
colnames(df_alpha_beta)[1] &lt;- &quot;alpha&quot;;
colnames(df_alpha_beta)[2] &lt;- &quot;beta&quot;;

df_alpha_beta &lt;- head(df_alpha_beta,500);

alpha_beta_scatter_plot &lt;-
  ggplot(df_alpha_beta, aes(x=alpha, y=beta)) +
  geom_point(size=2, alpha=0.25) +
  geom_vline(xintercept=0, colour=&quot;gray&quot;) +
  geom_hline(yintercept=0, colour=&quot;gray&quot;) +
  scale_x_continuous(name=&quot;occupancy log odds (alpha)&quot;, limits=c(-4,4)) +
  scale_y_continuous(name=&quot;detection log odds (beta)&quot;, limits=c(-4,4)) +
  ggtitle(&quot;Posterior: Site occupancy (alpha) vs. Detection (beta)&quot;);
plot(alpha_beta_scatter_plot);</code></pre>
<p><img src="dorazio-et-al-knitr_files/figure-html/unnamed-chunk-12-1.png" width="672" /></p>
</div>
<div id="posterior-predictive-checking" class="section level3">
<h3>Posterior Predictive Checking</h3>
<p>Going beyond the figures in the paper, we also provide a scatterplot of the posterior means for the estimates of the <span class="math inline">\(\psi\)</span> and <span class="math inline">\(\theta\)</span> parameters for the observed species with <span class="math inline">\(i \leq n\)</span>, using the following code.</p>
<pre class="r"><code>logit_theta_sims &lt;- extract(fit)$logit_theta;
logit_psi_sims &lt;- extract(fit)$logit_psi;
occurrence_hat &lt;- c();
detection_hat &lt;- c();
for (i in 1:n) {
  occurrence_hat[i] &lt;- mean(logit_psi_sims[,i]);
  detection_hat[i] &lt;- mean(logit_theta_sims[,i]);
}
df_psi_theta_fit &lt;-
  data.frame(occurrence_hat, detection_hat);

psi_theta_hat_scatter_plot &lt;-
  ggplot(df_psi_theta_fit, aes(x=occurrence_hat, y=detection_hat)) +
  geom_vline(xintercept=0, colour=&quot;gray&quot;) +
  geom_hline(yintercept=0, colour=&quot;gray&quot;) +
  geom_point(size=1.5) +
  scale_x_continuous(name=&quot;occurrence log odds&quot;,
                     limits=c(-8,8), breaks=2*(-4:4)) +
  scale_y_continuous(name=&quot;detection log odds&quot;,
                     limits=c(-8,8), breaks=2*(-4:4)) +
  ggtitle(&quot;Posterior Means: Species Occurrence (psi) and Detection (theta)&quot;);

plot(psi_theta_hat_scatter_plot);</code></pre>
<p><img src="dorazio-et-al-knitr_files/figure-html/unnamed-chunk-13-1.png" width="672" /></p>
<p>The actual fitted posterior means for the <span class="math inline">\(\theta\)</span> and <span class="math inline">\(\psi\)</span> parameters can be compared to a posterior simulation of a new species given the prior on <span class="math inline">\((u,v)\)</span> to perform an informal posterior predictive check. Only 500 random draws from the total of 10,000 drawn are shown.</p>
<pre class="r"><code>df_psi_theta_sim &lt;-
  data.frame(occurrence = extract(fit)$logit_psi_sim,
             detection= extract(fit)$logit_theta_sim);

df_psi_theta_sim &lt;- head(df_psi_theta_sim, 500);

psi_theta_sim_scatter_plot &lt;-
  ggplot(df_psi_theta_sim, aes(x=occurrence, y=detection)) +
  geom_vline(xintercept=0, colour=&quot;gray&quot;) +
  geom_hline(yintercept=0, colour=&quot;gray&quot;) +
  geom_point(size=1.5) +
  scale_x_continuous(name=&quot;occurrence log odds&quot;,
                     limits=c(-8,8), breaks=2*(-4:4)) +
  scale_y_continuous(name=&quot;detection log odds&quot;,
                     limits=c(-8,8), breaks=2*(-4:4)) +
  ggtitle(&quot;Posterior Predictive: Species Occurrence (psi) and Detection (theta)&quot;);

plot(psi_theta_sim_scatter_plot);</code></pre>
<p><img src="dorazio-et-al-knitr_files/figure-html/unnamed-chunk-14-1.png" width="672" /></p>
</div>
</div>
<div id="acknowledgements" class="section level2">
<h2>Acknowledgements</h2>
<p>Thanks to Mike Meredith for terminological and mathematical adjustments to the first version.</p>
</div>
<div id="licensing" class="section level2">
<h2>Licensing</h2>
<p>All code in this document is licensed via the BSD 3-clause license.</p>
</div>




</div>

<script>

// add bootstrap table styles to pandoc tables
$(document).ready(function () {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
});

</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
